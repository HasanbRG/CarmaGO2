<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Request Ride | CarmaGO</title>
  <link rel="stylesheet" href="styles/navbar.css" />
  <link rel="stylesheet" href="styles/req-ride.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  <script src="auth.js"></script>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <style>
    /* Toast notification styles */
    .toast {
      min-width: 220px;
      max-width: 340px;
      background: #222;
      color: #fff;
      padding: 14px 20px;
      border-radius: 14px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.11);
      opacity: 0;
      pointer-events: none;
      transform: translateY(30px) scale(0.95);
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: opacity 0.28s, transform 0.28s;
    }
    .toast.toast-success { background: #43b54b; color: #fff; }
    .toast.toast-error { background: #d62f2f; color: #fff; }
    .toast.toast-info { background: #3465a4; color: #fff; }
    .toast.toast-warning { background: #eab307; color: #222; }
    .toast.toast-show {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0) scale(1);
    }
    .toast .toast-icon { font-size: 19px; }

    /* Enhanced CSS animations and hover effects for the ride request UI */
    #cancelRideBtn {
      transition: background 0.3s, transform 0.3s, box-shadow 0.3s;
    }
    
    #cancelRideBtn:hover {
      background: linear-gradient(135deg, #e53935, #c62828) !important;
      transform: translateY(-1px);
      box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4) !important;
    }
    
    #cancelRideBtn:active {
      transform: translateY(0);
    }
    
    /* Enhanced active ride animations */
    #activeRideBox {
      animation: slideInUp 0.5s ease-out;
    }
    
    /* Disabled request button styles */
    #submitRideBtn:disabled {
      background: #bdbdbd !important;
      color: #757575 !important;
      cursor: not-allowed !important;
      transform: none !important;
      box-shadow: none !important;
    }
    
    #submitRideBtn:disabled:hover {
      background: #bdbdbd !important;
      transform: none !important;
    }
    
    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(30px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    
    #driverInfo {
      animation: fadeInScale 0.6s ease-out 0.3s both;
    }
    
    @keyframes fadeInScale {
      from {
        opacity: 0;
        transform: scale(0.9);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    /* Enhanced Error Handling and Retry Mechanism Styles */
    .retry-button {
      background: #2196f3;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-top: 10px;
    }
    
    .retry-button:hover {
      background: #1976d2;
      transform: translateY(-1px);
    }
    
    .network-error-indicator {
      background: linear-gradient(135deg, #ff5722, #e64a19);
      color: white;
      padding: 12px 16px;
      border-radius: 8px;
      margin: 10px 0;
      font-size: 0.9rem;
      font-weight: bold;
      box-shadow: 0 2px 8px rgba(255, 87, 34, 0.3);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .loading-spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #2196f3;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      animation: spin 1s linear infinite;
      display: inline-block;
      margin-right: 8px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Custom Cancel Confirmation Styles */
    .cancel-confirmation-container {
      margin-top: 1rem;
      padding: 1rem;
      background: rgba(255, 235, 238, 0.8);
      border-radius: 8px;
      border-left: 4px solid #f44336;
      display: none;
    }
    
    .cancel-confirmation-buttons {
      display: flex;
      gap: 12px;
      margin-top: 12px;
    }
    
    .confirm-cancel-btn {
      background: linear-gradient(135deg, #f44336, #d32f2f);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      flex: 1;
    }
    
    .confirm-cancel-btn:hover {
      background: linear-gradient(135deg, #e53935, #c62828);
      transform: translateY(-1px);
    }
    
    .keep-ride-btn {
      background: linear-gradient(135deg, #4caf50, #388e3c);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      flex: 1;
    }
    
    .keep-ride-btn:hover {
      background: linear-gradient(135deg, #43a047, #2e7d32);
      transform: translateY(-1px);
    }
    
    /* Emergency clear button styles */
    .emergency-clear-btn {
      background: linear-gradient(135deg, #ff5722, #e64a19) !important;
      color: white !important;
      font-size: 1.2rem !important;
      border: none !important;
      padding: 0.7rem !important;
      border-radius: 8px !important;
      font-weight: bold !important;
      cursor: pointer !important;
      transition: all 0.3s ease !important;
      opacity: 0.8 !important;
      width: 50px !important;
      height: auto !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      flex-shrink: 0 !important;
    }
    
    .emergency-clear-btn:hover:not(:disabled) {
      opacity: 1 !important;
      transform: translateY(-1px) rotate(180deg) !important;
      box-shadow: 0 3px 8px rgba(255, 87, 34, 0.4) !important;
    }
    
    .emergency-clear-btn:disabled {
      background: #bdbdbd !important;
      color: #757575 !important;
      cursor: not-allowed !important;
      opacity: 0.5 !important;
      transform: none !important;
      box-shadow: none !important;
    }
    
    .emergency-clear-btn:disabled:hover {
      transform: none !important;
      opacity: 0.5 !important;
    }
  </style>
</head>
<body>

<div class="navbar" data-page="ride">
  <div class="nav-container">
    <a href="HomePage.html" class="logo">
      <div class="logo-circle"></div>
      <span class="logo-text">CarmaGO</span>
    </a>
    
    <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">
      <span></span>
      <span></span>
      <span></span>
    </button>
    
    <nav>
      <ul class="nav-links" id="nav-links">
        <li><a href="HomePage.html"><i class="fas fa-home nav-icon"></i>Home</a></li>
        <li><a href="req-ride.html" class="active" data-auth-required="true"><i class="fas fa-car nav-icon"></i>Request Ride</a></li>
        <li><a href="account.html" data-auth-required="true"><i class="fas fa-user nav-icon"></i>Account</a></li>
        <li><a href="locate-car.html" data-auth-required="true"><i class="fas fa-map-marker-alt nav-icon"></i>Locate Cars</a></li>
        <li><a href="taxi-job.html" data-auth-required="true"><i class="fas fa-taxi nav-icon"></i>Taxi Jobs</a></li>
      </ul>
    </nav>
    
    <div class="auth-actions">
      <button id="logout-btn" class="signup-btn" onclick="logout()">
        <i class="fas fa-sign-out-alt"></i>Logout
      </button>
    </div>
  </div>
</div>

<div class="main-layout" style="display: flex; gap: 2rem; align-items: flex-start; padding: 2rem; flex-direction: column;">
  <div style="display: flex; gap: 2rem; width: 100%;">
    <div class="form-container" style="min-width: 320px; max-width: 400px; background: #fff; border-radius: 16px; box-shadow: 0 3px 16px rgba(0,0,0,0.07); padding: 2rem 2rem 1.5rem 2rem;">
      <h2 style="margin-top:0;">🚖 Request a Ride</h2>
      <label for="pickupInput" style="font-weight: 600;">Pickup Location:</label>
      <input id="pickupInput" placeholder="Enter pickup..." autocomplete="off">
      <label for="dropoffInput" style="font-weight: 600; margin-top: 12px;">Dropoff Location:</label>
      <input id="dropoffInput" placeholder="Enter dropoff..." autocomplete="off">
      <label for="fareInput" style="font-weight: 600; margin-top: 12px;">Fare (£):</label>
      <input id="fareInput" placeholder="Fare will auto-fill" readonly>
      
      <!-- Button container for Request Ride and Clear buttons -->
      <div style="display: flex; gap: 8px; align-items: center; margin-top: 18px;">
        <button id="submitRideBtn" onclick="submitRide()" style="flex: 1; background: #2e7d32; color: #fff; font-size: 1.05rem; border: none; padding: 0.7rem 0; border-radius: 8px; font-weight: bold; cursor:pointer; transition: all 0.3s ease;">Request Ride</button>
        
        <!-- Emergency clear button (next to request ride button) -->
        <button id="emergencyClearBtn" onclick="emergencyClearRideData()" class="emergency-clear-btn" title="Clear stuck ride data">
          🔄
        </button>
      </div>

      <div id="activeRideBox" class="hidden" style="margin-top: 30px; border-radius: 12px; border: 2px solid #ffecb3; background: linear-gradient(135deg, #fffde7 0%, #fff9c4 100%); padding: 1.5rem; box-shadow: 0 4px 20px rgba(255, 193, 7, 0.15);">
        <div style="display: flex; align-items: center; margin-bottom: 1rem;">
          <div style="width: 50px; height: 50px; background: linear-gradient(135deg, #ff9800, #f57c00); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 1rem; box-shadow: 0 2px 10px rgba(255, 152, 0, 0.3);">
            <span style="font-size: 24px;">🚖</span>
          </div>
          <div>
            <h3 style="margin: 0; color: #e65100; font-size: 1.2rem; font-weight: 700;">Active Ride</h3>
            <p style="margin: 0; color: #bf6900; font-size: 0.9rem;">Your ride request is being processed</p>
          </div>
        </div>
        
        <div style="background: rgba(255, 255, 255, 0.7); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
            <div>
              <p style="margin: 0 0 0.5rem 0; color: #5d4037; font-weight: 600; font-size: 0.85rem;">PICKUP LOCATION</p>
              <p style="margin: 0; color: #3e2723; font-weight: 500;"><span id="pickupText">--</span></p>
            </div>
            <div>
              <p style="margin: 0 0 0.5rem 0; color: #5d4037; font-weight: 600; font-size: 0.85rem;">DROPOFF LOCATION</p>
              <p style="margin: 0; color: #3e2723; font-weight: 500;"><span id="dropoffText">--</span></p>
            </div>
            <div style="grid-column: 1 / -1;">
              <p style="margin: 0 0 0.5rem 0; color: #5d4037; font-weight: 600; font-size: 0.85rem;">FARE</p>
              <p style="margin: 0; color: #2e7d32; font-weight: 700; font-size: 1.1rem;">£<span id="fareText">--</span></p>
            </div>
          </div>
        </div>
        
        <div id="rideStatus" style="margin: 1rem 0; padding: 1rem; background: rgba(255, 255, 255, 0.8); border-radius: 8px; color: #1b5e20; font-weight: 600; text-align: center; border-left: 4px solid #4caf50;"></div>
        
        <button onclick="showCancelRideConfirmation()" id="cancelRideBtn" style="width: 100%; background: linear-gradient(135deg, #f44336, #d32f2f); color: white; margin-top: 1rem; border: none; border-radius: 8px; font-weight: 600; padding: 0.8rem; cursor: pointer; font-size: 1rem; transition: all 0.3s ease; box-shadow: 0 2px 10px rgba(244, 67, 54, 0.3);">Cancel Ride</button>
        
        <div id="cancelConfirmation" class="cancel-confirmation-container">
          <div style="margin-bottom: 12px;">
            <h4 style="margin: 0 0 8px 0; color: #d32f2f; font-size: 1rem;">⚠️ Cancel Ride</h4>
            <p style="margin: 0; color: #5d4037; font-size: 0.9rem;">Are you sure you want to cancel this ride? The driver will be notified immediately.</p>
          </div>
          <div class="cancel-confirmation-buttons">
            <button onclick="confirmCancelRide()" class="confirm-cancel-btn">
              ✓ Yes, Cancel Ride
            </button>
            <button onclick="confirmForceCancelRide()" class="confirm-cancel-btn" style="background: linear-gradient(135deg, #ff5722, #e64a19); font-size: 0.9rem;">
              ⚡ Force Cancel (Local)
            </button>
            <button onclick="hideCancelRideConfirmation()" class="keep-ride-btn">
              ✗ Keep Ride
            </button>
          </div>
        </div>
      </div>
    </div>

    <div class="map-container" style="flex: 1; min-width: 330px; min-height: 380px; background: #e8e7e7; border-radius: 16px; box-shadow: 0 0 14px rgba(0,0,0,0.07);">
      <div id="map" style="width:100%; height:100%; min-height:380px; border-radius: 16px;"></div>
    </div>
  </div>
  
  <!-- Active ride tracking box (shown below map when ride is accepted) -->
  <div id="activeRideTrackingBox" class="hidden" style="width: 100%; border-radius: 16px; border: 2px solid #4caf50; background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%); padding: 2rem; box-shadow: 0 6px 25px rgba(76, 175, 80, 0.15); margin-top: 1rem;">
    <!-- Enhanced Driver/Car Info (shown when ride accepted) -->
    <div id="driverInfo" style="background: linear-gradient(135deg, #ffffff 0%, #f1f8e9 100%); border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem; border: 1px solid #a5d6a7; box-shadow: 0 2px 10px rgba(76, 175, 80, 0.1);">
      <div style="display: flex; align-items: center; margin-bottom: 1.5rem;">
        <div style="width: 55px; height: 55px; background: linear-gradient(135deg, #4caf50, #2e7d32); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 1.5rem; box-shadow: 0 3px 12px rgba(76, 175, 80, 0.4);">
          <span style="font-size: 24px; color: white;">�</span>
        </div>
        <div>
          <h4 style="margin: 0; color: #1b5e20; font-size: 1.3rem; font-weight: 700;">Live Ride Tracking</h4>
          <p style="margin: 0; color: #2e7d32; font-size: 1rem;">Following your ride in real-time</p>
        </div>
      </div>
      
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem;">
        <div style="background: rgba(255, 255, 255, 0.8); padding: 1rem; border-radius: 8px; border-left: 4px solid #4caf50;">
          <p style="margin: 0 0 0.5rem 0; color: #388e3c; font-weight: 600; font-size: 0.9rem;">DRIVER</p>
          <p style="margin: 0; color: #1b5e20; font-weight: 600; font-size: 1.1rem;"><span id="driverNameTracking">--</span></p>
        </div>
        <div style="background: rgba(255, 255, 255, 0.8); padding: 1rem; border-radius: 8px; border-left: 4px solid #2196f3;">
          <p style="margin: 0 0 0.5rem 0; color: #1565c0; font-weight: 600; font-size: 0.9rem;">VEHICLE</p>
          <p style="margin: 0; color: #0d47a1; font-weight: 600; font-size: 1.1rem;"><span id="carInfoTracking">--</span></p>
        </div>
        <div style="background: rgba(255, 255, 255, 0.8); padding: 1rem; border-radius: 8px; border-left: 4px solid #ff9800;">
          <p style="margin: 0 0 0.5rem 0; color: #f57c00; font-weight: 600; font-size: 0.9rem;">CURRENT LOCATION</p>
          <p style="margin: 0; color: #e65100; font-weight: 500; font-size: 0.95rem;"><span id="carLocationTextTracking">--</span></p>
        </div>
        <div style="background: rgba(255, 255, 255, 0.8); padding: 1rem; border-radius: 8px; border-left: 4px solid #9c27b0;">
          <p style="margin: 0 0 0.5rem 0; color: #7b1fa2; font-weight: 600; font-size: 0.9rem;"><span id="etaLabelTracking">ARRIVAL ETA</span></p>
          <p style="margin: 0; color: #4a148c; font-weight: 700; font-size: 1.2rem;"><span id="driverETATracking">--</span></p>
        </div>
      </div>
    </div>
    
    <div id="rideStatusTracking" style="margin: 0 0 1.5rem 0; padding: 1.5rem; background: rgba(255, 255, 255, 0.9); border-radius: 12px; color: #1b5e20; font-weight: 600; text-align: center; border-left: 6px solid #4caf50; font-size: 1.1rem; box-shadow: 0 2px 8px rgba(76, 175, 80, 0.1);"></div>
    
    <!-- Cancel button for tracking layout -->
    <button onclick="showCancelRideConfirmationTracking()" id="cancelRideBtnTracking" style="width: 100%; background: linear-gradient(135deg, #f44336, #d32f2f); color: white; border: none; border-radius: 8px; font-weight: 600; padding: 0.8rem; cursor: pointer; font-size: 1rem; transition: all 0.3s ease; box-shadow: 0 2px 10px rgba(244, 67, 54, 0.3);">Cancel Ride</button>
    
    <div id="cancelConfirmationTracking" class="cancel-confirmation-container">
      <div style="margin-bottom: 12px;">
        <h4 style="margin: 0 0 8px 0; color: #d32f2f; font-size: 1rem;">⚠️ Cancel Ride</h4>
        <p style="margin: 0; color: #5d4037; font-size: 0.9rem;">Are you sure you want to cancel this ride? The driver will be notified immediately.</p>
      </div>
      <div class="cancel-confirmation-buttons">
        <button onclick="confirmCancelRideTracking()" class="confirm-cancel-btn">
          ✓ Yes, Cancel Ride
        </button>
        <button onclick="confirmForceCancelRideTracking()" class="confirm-cancel-btn" style="background: linear-gradient(135deg, #ff5722, #e64a19); font-size: 0.9rem;">
          ⚡ Force Cancel (Local)
        </button>
        <button onclick="hideCancelRideConfirmationTracking()" class="keep-ride-btn">
          ✗ Keep Ride
        </button>
      </div>
    </div>
  </div>
</div>

<script>
// Immediate authentication check using shared auth system
if (!requireAuthentication("Please log in to request a ride")) {
  // Page will redirect to login, stop execution
}

let pickupCoords = null;
let dropoffCoords = null;
let pickupAddress = '';
let dropoffAddress = '';
let map, pickupMarker, dropoffMarker, directionsService, directionsRenderer;
let rideId = null;
let socket = null;
let etaMins = null;
let assignedCarId = null;
let assignedCarMarker = null;
let rideStatus = 'none'; // none, pending, accepted, driving_to_pickup, in_progress, completed
let currentRideData = null;
let locationUpdateInterval = null; // For periodic location updates

// Enhanced map initialization with error handling
window.initMap = function() {
  try {
    if (!google || !google.maps) {
      throw new Error("Google Maps API not loaded");
    }
    
    map = new google.maps.Map(document.getElementById('map'), {
      center: { lat: 51.4545, lng: -2.5879 },
      zoom: 13,
      mapTypeControl: true,
      streetViewControl: true,
      fullscreenControl: true,
      zoomControl: true
    });

    directionsService = new google.maps.DirectionsService();
    directionsRenderer = new google.maps.DirectionsRenderer({ 
      map: map,
      suppressMarkers: false,
      polylineOptions: {
        strokeColor: '#2196f3',
        strokeWeight: 4,
        strokeOpacity: 0.8
      }
    });

    // Setup enhanced autocomplete
    setupAutocomplete();
    
    // Initialize socket connection
    connectSocket();
    
    showToast("Map loaded successfully!", "success");
    
  } catch (error) {
    console.error("Error initializing map:", error);
    showToast("Failed to load map. Please refresh the page.", "error");
    handleGoogleMapsError();
  }
};

// Enhanced Google Maps API error handling
function handleGoogleMapsError() {
  showToast("Google Maps failed to load. Please refresh the page.", "error");
  console.error("Google Maps API error");
}

// Enhanced autocomplete with error handling
function setupAutocomplete() {
  try {
    const pickupInput = document.getElementById('pickupInput');
    const dropoffInput = document.getElementById('dropoffInput');
    
    if (!pickupInput || !dropoffInput) {
      throw new Error("Input elements not found");
    }
    
    const pickupAutocomplete = new google.maps.places.Autocomplete(pickupInput, {
      fields: ['geometry', 'formatted_address'],
      types: ['geocode']
    });
    pickupAutocomplete.bindTo('bounds', map);
    
    const dropoffAutocomplete = new google.maps.places.Autocomplete(dropoffInput, {
      fields: ['geometry', 'formatted_address'],
      types: ['geocode']
    });
    dropoffAutocomplete.bindTo('bounds', map);
    
    pickupAutocomplete.addListener('place_changed', () => {
      try {
        const place = pickupAutocomplete.getPlace();
        if (!place.geometry || !place.geometry.location) {
          showToast('Invalid pickup location. Please select from suggestions.', 'error');
          return;
        }
        
        pickupCoords = {
          lat: place.geometry.location.lat(),
          lng: place.geometry.location.lng()
        };
        
        pickupAddress = place.formatted_address || pickupInput.value;
        
        if (pickupMarker) pickupMarker.setMap(null);
        pickupMarker = new google.maps.Marker({
          position: pickupCoords,
          map: map,
          title: "Pickup Location",
          icon: {
            url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEyIDJDOC4xMyAyIDUgNS4xMyA1IDlDNSAxNC4yNSAxMiAyMiAxMiAyMkMxMiAyMiAxOSAxNC4yNSAxOSA5QzE5IDUuMTMgMTUuODcgMiAxMiAyWk0xMiAxMS41QzEwLjYyIDExLjUgOS41IDEwLjM4IDkuNSA5QzkuNSA3LjYyIDEwLjYyIDYuNSAxMiA2LjVDMTMuMzggNi41IDE0LjUgNy42MiAxNC41IDlDMTQuNSAxMC4zOCAxMy4zOCAxMS41IDEyIDExLjVaIiBmaWxsPSIjNGNhZjUwIi8+Cjwvc3ZnPgo=',
            scaledSize: new google.maps.Size(24, 24)
          }
        });
        
        map.panTo(pickupCoords);
        calculateFare();
      } catch (error) {
        console.error("Error setting pickup location:", error);
        showToast("Error setting pickup location", "error");
      }
    });
    
    dropoffAutocomplete.addListener('place_changed', () => {
      try {
        const place = dropoffAutocomplete.getPlace();
        if (!place.geometry || !place.geometry.location) {
          showToast('Invalid dropoff location. Please select from suggestions.', 'error');
          return;
        }
        
        dropoffCoords = {
          lat: place.geometry.location.lat(),
          lng: place.geometry.location.lng()
        };
        
        dropoffAddress = place.formatted_address || dropoffInput.value;
        
        if (dropoffMarker) dropoffMarker.setMap(null);
        dropoffMarker = new google.maps.Marker({
          position: dropoffCoords,
          map: map,
          title: "Dropoff Location",
          icon: {
            url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1zbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEyIDJDOC4xMyAyIDUgNS4xMyA1IDlDNSAxNC4yNSAxMiAyMiAxMiAyMkMxMiAyMiAxOSAxNC4yNSAxOSA5QzE5IDUuMTMgMTUuODcgMiAxMiAyWk0xMiAxMS41QzEwLjYyIDExLjUgOS41IDEwLjM4IDkuNSA5QzkuNSA3LjYyIDEwLjYyIDYuNSAxMiA2LjVDMTMuMzggNi41IDE0LjUgNy42MiAxNC41IDlDMTQuNSAxMC4zOCAxMy4zOCAxMS41IDEyIDExLjVaIiBmaWxsPSIjZjQ0MzM2Ii8+Cjwvc3ZnPgo=',
            scaledSize: new google.maps.Size(24, 24)
          }
        });
        
        map.panTo(dropoffCoords);
        calculateFare();
      } catch (error) {
        console.error("Error setting dropoff location:", error);
        showToast("Error setting dropoff location", "error");
      }
    });
    
  } catch (error) {
    console.error("Error setting up autocomplete:", error);
    showToast("Error setting up location search", "error");
  }
}

// Enhanced fare calculation with error handling
function calculateFare() {
  if (!pickupCoords || !dropoffCoords) {
    return;
  }
  
  try {
    const service = new google.maps.DistanceMatrixService();
    service.getDistanceMatrix({
      origins: [pickupCoords],
      destinations: [dropoffCoords],
      travelMode: google.maps.TravelMode.DRIVING,
      unitSystem: google.maps.UnitSystem.METRIC,
      avoidHighways: false,
      avoidTolls: false
    }, (response, status) => {
      try {
        if (status !== 'OK') {
          throw new Error(`Distance calculation failed: ${status}`);
        }
        
        const element = response.rows[0].elements[0];
        if (element.status !== 'OK') {
          throw new Error(`Route not found: ${element.status}`);
        }
        
        const distance = element.distance.value / 1000; // km
        const duration = element.duration.value / 60; // minutes
        
        // Enhanced fare calculation: £2.50 base + £1.20/km + £0.15/minute
        const baseFare = 2.50;
        const perKm = 1.20;
        const perMinute = 0.15;
        const estimatedFare = baseFare + (distance * perKm) + (duration * perMinute);
        
        const fareInput = document.getElementById('fareInput');
        if (fareInput) {
          fareInput.value = Math.max(2.50, estimatedFare).toFixed(2);
        }
        
        // Show route on map
        directionsService.route({
          origin: pickupCoords,
          destination: dropoffCoords,
          travelMode: google.maps.TravelMode.DRIVING
        }, (result, status) => {
          if (status === 'OK') {
            directionsRenderer.setDirections(result);
          } else {
            console.warn("Directions request failed:", status);
          }
        });
        
      } catch (error) {
        console.error("Error processing distance calculation:", error);
        showToast("Error calculating fare. Please try again.", "error");
      }
    });
    
  } catch (error) {
    console.error("Error calculating fare:", error);
    showToast("Error calculating fare", "error");
  }
}

let isSubmittingRide = false; // Global flag to prevent double submissions

async function submitRide() {
  // Prevent double submission
  if (isSubmittingRide) {
    showToast("Please wait, processing your request...", "warning");
    return;
  }

  // Check if there's already an active ride
  if (rideStatus !== 'none' && rideStatus !== 'completed' && rideStatus !== 'cancelled') {
    showToast("You already have an active ride", "error");
    return;
  }

  isSubmittingRide = true;

  // Get user ID and email from localStorage with validation
  const riderId = localStorage.getItem("loggedInUserId");
  const riderEmail = localStorage.getItem("loggedInUser");

  // Enhanced user validation
  if (!riderId || !riderEmail) {
    showToast("Please log in first", "error");
    setTimeout(() => window.location.href = "logInpage.html", 2000);
    return;
  }

  // Comprehensive input validation
  const fareInput = document.getElementById('fareInput');
  if (!pickupCoords || !dropoffCoords || !fareInput || !fareInput.value) {
    showToast("Please fill all fields properly", "error");
    return;
  }

  // Validate coordinates
  if (!validateCoordinates(pickupCoords) || !validateCoordinates(dropoffCoords)) {
    showToast("Invalid pickup or dropoff location", "error");
    return;
  }

  // Validate addresses
  if (!validateAddress(pickupAddress) || !validateAddress(dropoffAddress)) {
    showToast("Please enter valid pickup and dropoff addresses", "error");
    return;
  }

  // Validate fare
  const fareEstimate = parseFloat(fareInput.value);
  if (isNaN(fareEstimate) || fareEstimate <= 0 || fareEstimate > 1000) {
    showToast("Please enter a valid fare amount (£0.01 - £1000)", "error");
    return;
  }

  // Check if locations are too close (minimum 100m)
  const distance = google.maps.geometry.spherical.computeDistanceBetween(
    new google.maps.LatLng(pickupCoords.lat, pickupCoords.lng),
    new google.maps.LatLng(dropoffCoords.lat, dropoffCoords.lng)
  );
  
  if (distance < 100) {
    showToast("Pickup and dropoff locations are too close (minimum 100m required)", "error");
    return;
  }

  showLoading("submitRideBtn", "Requesting ride...");

  try {
    const response = await retryOperation(async () => {
      const res = await fetch("http://localhost:5001/request-ride", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          riderId: sanitizeInput(riderId),
          riderEmail: sanitizeInput(riderEmail),
          pickup: { 
            lat: Math.round(pickupCoords.lat * 1000000) / 1000000, 
            lng: Math.round(pickupCoords.lng * 1000000) / 1000000 
          },
          dropoff: { 
            lat: Math.round(dropoffCoords.lat * 1000000) / 1000000, 
            lng: Math.round(dropoffCoords.lng * 1000000) / 1000000 
          },
          pickupAddress: sanitizeInput(pickupAddress),
          dropoffAddress: sanitizeInput(dropoffAddress),
          fareEstimate: Math.round(fareEstimate * 100) / 100
        }),
        timeout: 15000
      });

      if (!res.ok) {
        if (res.status === 429) {
          throw new Error("Too many requests. Please wait a moment and try again.");
        } else if (res.status === 503) {
          throw new Error("Service temporarily unavailable. Please try again later.");
        } else {
          const error = await res.json();
          throw new Error(error.error || `HTTP ${res.status}: ${res.statusText}`);
        }
      }

      return res.json();
    });

    if (response.status === "ok" && response.rideRequestId) {
      rideId = response.rideRequestId;
      rideStatus = 'pending';
      
      // Safely update UI elements
      const elements = {
        pickupText: pickupAddress,
        dropoffText: dropoffAddress,
        fareText: fareEstimate.toFixed(2),
        rideStatus: "⌛ Waiting for a driver to accept..."
      };

      Object.entries(elements).forEach(([id, value]) => {
        const element = document.getElementById(id);
        if (element) {
          element.textContent = value;
          if (id === 'rideStatus') {
            element.style.color = "#c48811";
          }
        }
      });

      const activeRideBox = document.getElementById("activeRideBox");
      if (activeRideBox) {
        activeRideBox.classList.remove("hidden");
      }
      
      // Update request button state
      updateRequestButtonState();
      
      // Save ride state to localStorage
      saveRideState();
      
      showToast("Ride request sent! Waiting for driver...", "info");
      
      // Initialize socket connection for real-time updates
      connectSocket();
    } else {
      throw new Error("Invalid response from server");
    }
  } catch (error) {
    console.error("Error requesting ride:", error);
    
    // Specific error handling
    let errorMessage = "Failed to request ride. Please try again.";
    if (error.message.includes("network") || error.message.includes("fetch")) {
      errorMessage = "Network error. Please check your connection and try again.";
    } else if (error.message.includes("timeout")) {
      errorMessage = "Request timed out. Please try again.";
    } else if (error.message) {
      errorMessage = error.message;
    }
    
    showToast(errorMessage, "error");
  } finally {
    hideLoading("submitRideBtn", "Request Ride");
    isSubmittingRide = false; // Reset flag
  }
}

async function cancelRide(forceCancel = false) {
  if (!rideId) {
    showToast("No active ride to cancel", "error");
    return;
  }

  // Show appropriate loading text
  const loadingText = forceCancel ? "Force cancelling..." : "Cancelling...";
  showLoading("cancelRideBtn", loadingText);
  
  // Also handle tracking button if it exists
  const cancelTrackingBtn = document.getElementById("cancelRideBtnTracking");
  if (cancelTrackingBtn) {
    showLoading("cancelRideBtnTracking", loadingText);
  }

  try {
    let serverCancelSuccess = false;
    
    if (!forceCancel) {
      // Try to cancel on server first
      try {
        const response = await retryOperation(async () => {
          const res = await fetch("http://localhost:5001/cancel-ride", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              rideId: sanitizeInput(rideId),
              cancelledBy: "rider",
              reason: "Cancelled by rider"
            }),
            timeout: 8000  // Reduced timeout
          });

          if (!res.ok) {
            const error = await res.json();
            throw new Error(error.error || `HTTP ${res.status}: ${res.statusText}`);
          }

          return res.json();
        }, 2); // Only 2 retries for cancellation

        if (response.status === "cancelled") {
          serverCancelSuccess = true;
        }
      } catch (serverError) {
        console.warn("Server cancellation failed:", serverError.message);
        // Don't throw here - we'll handle force cancel below
      }
    }
    
    // Always clear local state, regardless of server response
    clearRideState();
    resetRideState();
    
    if (forceCancel) {
      showToast("Ride cancelled locally. You can now make a new request.", "success");
    } else if (serverCancelSuccess) {
      showToast("Ride cancelled successfully", "success");
    } else {
      showToast("Ride cancelled locally (server may be unavailable)", "warning");
    }
    
  } catch (error) {
    console.error("Error in cancel process:", error);
    // Force clear local state even on unexpected errors
    clearRideState();
    resetRideState();
    showToast("Ride cancelled locally due to error", "warning");
  } finally {
    hideLoading("cancelRideBtn", "Cancel Ride");
    if (cancelTrackingBtn) {
      hideLoading("cancelRideBtnTracking", "Cancel Ride");
    }
  }
}

function keepRide() {
  hideCancelRideConfirmation();
}

function updateAssignedCarInfo(data) {
  // Only update if ride is accepted or in progress
  if (rideStatus !== 'accepted' && rideStatus !== 'driving_to_pickup' && 
      rideStatus !== 'arrived_at_pickup' && rideStatus !== 'in_progress') {
    console.warn("Attempted to update car info for non-accepted ride:", rideStatus);
    return;
  }

  // Only update elements that exist in the DOM
  const driverNameEl = document.getElementById("driverName");
  const carInfoEl = document.getElementById("carInfo");
  const driverNameTrackingEl = document.getElementById("driverNameTracking");
  const carInfoTrackingEl = document.getElementById("carInfoTracking");
  
  const driverName = data.driverName || data.carOwnerEmail || "Driver";
  const carInfo = `${data.carName || 'Car'} (${data.carModel || 'Unknown model'})`;
  
  // Update main elements (if they exist)
  if (driverNameEl) driverNameEl.textContent = driverName;
  if (carInfoEl) carInfoEl.textContent = carInfo;
  
  // Update tracking elements (these should always exist)
  if (driverNameTrackingEl) driverNameTrackingEl.textContent = driverName;
  if (carInfoTrackingEl) carInfoTrackingEl.textContent = carInfo;
  
  // Add car marker to map if we have location
  if (data.carLocation) {
    updateAssignedCarLocation(data.carLocation.lat, data.carLocation.lng);
  }
}

function updateAssignedCarLocation(lat, lng) {
  // Only update if we have a valid map and coordinates
  if (!map || !lat || !lng) {
    console.warn("Cannot update car location: missing map or coordinates");
    return;
  }

  const position = { lat: parseFloat(lat), lng: parseFloat(lng) };
  
  // Validate coordinates
  if (isNaN(position.lat) || isNaN(position.lng)) {
    console.warn("Invalid coordinates for car location:", lat, lng);
    return;
  }
  
  if (assignedCarMarker) {
    assignedCarMarker.setPosition(position);
    console.log("Updated car marker position to:", position);
  } else {
    assignedCarMarker = new google.maps.Marker({
      position,
      map,
      icon: {
        url: "https://img.icons8.com/color/48/car--v1.png",
        scaledSize: new google.maps.Size(40, 40),
      },
      title: "Your assigned car"
    });
    console.log("Created new car marker at:", position);
  }
  
  // Update car location text - only if elements exist
  const geocoder = new google.maps.Geocoder();
  geocoder.geocode({ location: position }, (results, status) => {
    if (status === "OK" && results[0]) {
      const address = results[0].formatted_address;
      const carLocationTextEl = document.getElementById("carLocationText");
      const carLocationTextTrackingEl = document.getElementById("carLocationTextTracking");
      
      if (carLocationTextEl) carLocationTextEl.textContent = address;
      if (carLocationTextTrackingEl) carLocationTextTrackingEl.textContent = address;
    } else {
      const coords = `${lat.toFixed(5)}, ${lng.toFixed(5)}`;
      const carLocationTextEl = document.getElementById("carLocationText");
      const carLocationTextTrackingEl = document.getElementById("carLocationTextTracking");
      
      if (carLocationTextEl) carLocationTextEl.textContent = coords;
      if (carLocationTextTrackingEl) carLocationTextTrackingEl.textContent = coords;
    }
  });
}

function updateRideETA(data) {
  if (data.driverETA) {
    console.log("Updating ETA to:", data.driverETA); // Debug log
    
    // Only update elements that exist in the DOM
    const etaTextEl = document.getElementById("etaText");
    const driverETATrackingEl = document.getElementById("driverETATracking");
    
    // Parse ETA for milestone notifications
    const etaMatch = data.driverETA.match(/(\d+)m\s*(\d+)s/);
    if (etaMatch) {
      const minutes = parseInt(etaMatch[1]) || 0;
      const seconds = parseInt(etaMatch[2]) || 0;
      const totalSeconds = minutes * 60 + seconds;
      
      // Show milestone notifications based on ETA
      if (rideStatus === 'driving_to_pickup') {
        if (totalSeconds <= 60 && !window.etaNotified60s) {
          showToast("⏰ Your driver will arrive in less than 1 minute!", "info");
          window.etaNotified60s = true;
        } else if (totalSeconds <= 120 && !window.etaNotified2m) {
          showToast("⏰ Your driver will arrive in about 2 minutes!", "info");
          window.etaNotified2m = true;
        } else if (totalSeconds <= 300 && !window.etaNotified5m) {
          showToast("⏰ Your driver will arrive in about 5 minutes!", "info");
          window.etaNotified5m = true;
        }
      }
    }
    
    // Use ETA format from backend (e.g., "2m 30s")
    if (etaTextEl) etaTextEl.textContent = data.driverETA;
    if (driverETATrackingEl) driverETATrackingEl.textContent = data.driverETA;
  }
}

// Periodic location update functions
function startLocationUpdates() {
  if (locationUpdateInterval) {
    clearInterval(locationUpdateInterval);
  }
  
  console.log("Starting periodic location updates for ride:", rideId);
  locationUpdateInterval = setInterval(() => {
    if (socket && socket.connected && rideId && assignedCarId) {
      console.log("Requesting location update for car:", assignedCarId);
      socket.emit("request-location-update", { 
        rideId: rideId, 
        carId: assignedCarId 
      });
    }
  }, 3000); // Update every 3 seconds
}

function stopLocationUpdates() {
  if (locationUpdateInterval) {
    console.log("Stopping periodic location updates");
    clearInterval(locationUpdateInterval);
    locationUpdateInterval = null;
  }
}

function showTrackingLayout(data) {
  // Only show tracking layout if ride is accepted or in progress
  if (rideStatus !== 'accepted' && rideStatus !== 'driving_to_pickup' && 
      rideStatus !== 'arrived_at_pickup' && rideStatus !== 'in_progress') {
    console.warn("Attempted to show tracking layout for non-accepted ride:", rideStatus);
    return;
  }

  // Hide the original active ride box (if it exists)
  const activeRideBox = document.getElementById("activeRideBox");
  if (activeRideBox) {
    activeRideBox.classList.add("hidden");
  }
  
  // Show the new tracking layout (if it exists)
  const activeRideTrackingBox = document.getElementById("activeRideTrackingBox");
  if (activeRideTrackingBox) {
    activeRideTrackingBox.classList.remove("hidden");
  }
  
  // Update assigned car info in tracking layout
  if (data) {
    updateAssignedCarInfo(data);
  }
}

function saveRideState() {
  try {
    const fareInput = document.getElementById('fareInput');
    const etaElement = document.getElementById('driverETATracking') || document.getElementById('etaText');
    
    const rideState = {
      rideId,
      assignedCarId,
      rideStatus,
      currentRideData,
      pickupCoords,
      dropoffCoords,
      pickupAddress,
      dropoffAddress,
      fareEstimate: fareInput ? fareInput.value : '0',
      etaText: etaElement ? etaElement.textContent : '--',
      timestamp: Date.now() // Add timestamp for expiration checking
    };
    localStorage.setItem('activeRide', JSON.stringify(rideState));
  } catch (error) {
    console.error("Error saving ride state:", error);
    // Continue execution even if saving fails
  }
}

function clearRideState() {
  // Clear localStorage
  localStorage.removeItem('activeRide');
  
  // Reset ETA notification flags
  window.etaNotified60s = false;
  window.etaNotified2m = false;
  window.etaNotified5m = false;
  
  // Also disconnect from ride-specific socket events
  if (socket && socket.connected && rideId) {
    console.log("Leaving ride room:", rideId);
    socket.emit("leave-ride-room", { rideId: rideId });
  }
  
  // Stop location updates
  stopLocationUpdates();
}

function checkForOngoingRide() {
  const savedRide = localStorage.getItem('activeRide');
  if (savedRide) {
    try {
      const rideState = JSON.parse(savedRide);
      
      // Validate the ride state before restoring
      if (!rideState.rideId || !rideState.rideStatus) {
        console.warn("Invalid ride state found, clearing...");
        clearRideState();
        return;
      }
      
      // Check if ride is too old (more than 2 hours)
      const now = Date.now();
      const rideStateTimestamp = rideState.timestamp || 0;
      const TWO_HOURS = 2 * 60 * 60 * 1000;
      
      if (now - rideStateTimestamp > TWO_HOURS) {
        console.warn("Ride state is too old, clearing...");
        clearRideState();
        showToast("Old ride data cleared", "info");
        return;
      }
      
      // Restore ride state
      rideId = rideState.rideId;
      assignedCarId = rideState.assignedCarId;
      rideStatus = rideState.rideStatus;
      currentRideData = rideState.currentRideData;
      pickupCoords = rideState.pickupCoords;
      dropoffCoords = rideState.dropoffCoords;
      pickupAddress = rideState.pickupAddress;
      dropoffAddress = rideState.dropoffAddress;        // Restore UI
        if (rideStatus !== 'none' && rideStatus !== 'completed' && rideStatus !== 'cancelled') {
          // Update request button state
          updateRequestButtonState();
          
          const pickupInput = document.getElementById('pickupInput');
          const dropoffInput = document.getElementById('dropoffInput');
          const fareInput = document.getElementById('fareInput');
          const pickupText = document.getElementById("pickupText");
          const dropoffText = document.getElementById("dropoffText");
          const fareText = document.getElementById("fareText");
        
        if (pickupInput) pickupInput.value = pickupAddress;
        if (dropoffInput) dropoffInput.value = dropoffAddress;
        if (fareInput) fareInput.value = rideState.fareEstimate;
        
        if (pickupText) pickupText.textContent = pickupAddress;
        if (dropoffText) dropoffText.textContent = dropoffAddress;
        if (fareText) fareText.textContent = rideState.fareEstimate;
        
        // Only set ETA if element exists (it was removed from active ride box)
        const etaElement = document.getElementById("driverETATracking");
        if (etaElement && rideState.etaText) {
          etaElement.textContent = rideState.etaText;
        }
        
        if (rideStatus === 'pending') {
          const rideStatusEl = document.getElementById("rideStatus");
          const activeRideBox = document.getElementById("activeRideBox");
          if (rideStatusEl) {
            rideStatusEl.textContent = "⌛ Waiting for a driver to accept...";
            rideStatusEl.style.color = "#c48811";
          }
          if (activeRideBox) {
            activeRideBox.classList.remove("hidden");
          }
        } else if (rideStatus === 'accepted' || rideStatus === 'driving_to_pickup' || rideStatus === 'arrived_at_pickup' || rideStatus === 'in_progress') {
          showTrackingLayout(currentRideData);
          
          // Restore markers if coordinates exist
          if (pickupCoords) {
            pickupMarker = new google.maps.Marker({
              position: pickupCoords,
              map,
              label: "P",
            });
          }
          if (dropoffCoords) {
            dropoffMarker = new google.maps.Marker({
              position: dropoffCoords,
              map,
              label: "D",
            });
          }
          
          // Calculate and show route
          if (pickupCoords && dropoffCoords) {
            calculateFare();
          }
        }
        
        showToast("Restored ongoing ride!", "info");
      } else {
        clearRideState();
      }
    } catch (error) {
      console.error("Error restoring ride state:", error);
      clearRideState();
    }
  }
}

function updateRideStatusDisplay(data) {
  const statusMessages = {
    'driving_to_pickup': '🚗 Driver is on the way to pick you up...',
    'arrived_at_pickup': '🚗 Driver has arrived - starting your journey!',
    'in_progress': '🚗 Driving to your destination...',
    'completed': '✅ Ride completed successfully!',
    'cancelled': '❌ Ride was cancelled'
  };
  
  if (statusMessages[data.status]) {
    // Update both status elements (for active ride box and tracking layout)
    const rideStatusEl = document.getElementById("rideStatus");
    const rideStatusTrackingEl = document.getElementById("rideStatusTracking");
    
    if (rideStatusEl) {
      rideStatusEl.textContent = statusMessages[data.status];
    }
    if (rideStatusTrackingEl) {
      rideStatusTrackingEl.textContent = statusMessages[data.status];
    }
    rideStatus = data.status;
    
    if (data.status === 'completed' || data.status === 'cancelled') {
      // Immediately hide the tracking layout for completed/cancelled rides
      const activeRideTrackingBox = document.getElementById("activeRideTrackingBox");
      if (activeRideTrackingBox) {
        activeRideTrackingBox.classList.add("hidden");
      }
      
      // Stop location updates immediately
      stopLocationUpdates();
      
      // Clear the assigned car marker immediately
      if (assignedCarMarker) {
        assignedCarMarker.setMap(null);
        assignedCarMarker = null;
      }
      
      // Reset state after showing the message briefly
      setTimeout(() => resetRideState(), 1500);
    }
  }
}

function updateRequestButtonState() {
  const submitBtn = document.getElementById("submitRideBtn");
  if (!submitBtn) return;
  
  if (rideStatus !== 'none' && rideStatus !== 'completed' && rideStatus !== 'cancelled') {
    // Disable submit button when ride is active
    submitBtn.disabled = true;
    submitBtn.textContent = "Ride in Progress...";
  } else {
    // Enable submit button when no active ride
    submitBtn.disabled = false;
    submitBtn.textContent = "Request Ride";
  }
  
  // Emergency clear button is always enabled
  const emergencyBtn = document.getElementById("emergencyClearBtn");
  if (emergencyBtn) {
    emergencyBtn.disabled = false;
    emergencyBtn.title = "Clear stuck ride data";
  }
}

function resetRideState() {
  rideId = null;
  assignedCarId = null;
  rideStatus = 'none';
  currentRideData = null;
  isSubmittingRide = false; // Reset submission flag
  
  // Update request button state
  updateRequestButtonState();
  
  // Clear markers
  if (assignedCarMarker) {
    assignedCarMarker.setMap(null);
    assignedCarMarker = null;
  }
  
  // Clear UI elements safely
  const activeRideBox = document.getElementById("activeRideBox");
  const activeRideTrackingBox = document.getElementById("activeRideTrackingBox");
  
  if (activeRideBox) activeRideBox.classList.add("hidden");
  if (activeRideTrackingBox) activeRideTrackingBox.classList.add("hidden");
  
  // Clear directions
  if (directionsRenderer) {
    directionsRenderer.setDirections({routes: []});
  }
  
  // Reset input fields safely
  const pickupInput = document.getElementById('pickupInput');
  const dropoffInput = document.getElementById('dropoffInput');
  const fareInput = document.getElementById('fareInput');
  
  if (pickupInput) pickupInput.value = '';
  if (dropoffInput) dropoffInput.value = '';
  if (fareInput) fareInput.value = '';
  
  // Reset coordinates
  pickupCoords = null;
  dropoffCoords = null;
  pickupAddress = '';
  dropoffAddress = '';
  
  // Clear markers
  if (pickupMarker) {
    pickupMarker.setMap(null);
    pickupMarker = null;
  }
  if (dropoffMarker) {
    dropoffMarker.setMap(null);
    dropoffMarker = null;
  }
}

// Utility functions for better calculations
function calculateDistance(lat1, lng1, lat2, lng2) {
  const R = 6371; // Earth's radius in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLng = (lng2 - lng1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLng/2) * Math.sin(dLng/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

function calculateETA(currentLat, currentLng, targetLat, targetLng) {
  const distance = calculateDistance(currentLat, currentLng, targetLat, targetLng);
  
  // Calculate based on actual simulation parameters
  // Assuming 8 waypoints max, 3 steps per waypoint, 0.8s per step
  const waypointsNeeded = Math.min(8, Math.max(2, Math.floor(distance * 3))); // More waypoints for longer distances
  const totalSimulationSteps = waypointsNeeded * 3; // 3 steps per waypoint
  const stepDelay = 0.8; // seconds per step
  
  // Total simulation time in seconds
  let totalSeconds = totalSimulationSteps * stepDelay;
  
  // Add pickup wait time (2 seconds) and some buffer
  totalSeconds += 3;
  
  // Convert to minutes and seconds for display
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = Math.floor(totalSeconds % 60);
  
  if (minutes > 0) {
    return `${minutes}m ${seconds}s`;
  } else {
    return `${seconds}s`;
  }
}

// Enhanced Error Handling and Retry Utilities
const MAX_RETRIES = 3;
const RETRY_DELAY = 1000;
const REQUEST_TIMEOUT = 15000;

// Network status monitoring
let isOnline = navigator.onLine;
let networkErrorCount = 0;

window.addEventListener('online', () => {
  isOnline = true;
  networkErrorCount = 0;
  showToast("Connection restored", "success");
  hideNetworkError();
});

window.addEventListener('offline', () => {
  isOnline = false;
  showToast("No internet connection", "error");
  showNetworkError();
});

// Input validation utilities
function validateCoordinates(coords) {
  return coords && 
         typeof coords.lat === 'number' && 
         typeof coords.lng === 'number' &&
         coords.lat >= -90 && coords.lat <= 90 &&
         coords.lng >= -180 && coords.lng <= 180;
}

function validateAddress(address) {
  return address && 
         typeof address === 'string' && 
         address.trim().length >= 3 &&
         address.trim().length <= 200;
}

function sanitizeInput(input) {
  if (typeof input !== 'string') return '';
  return input.trim().replace(/[<>\"'&]/g, '');
}

// Enhanced toast notification system with error tracking
function showToast(message, type = "info", duration = 4000) {
  try {
    const toastContainer = document.getElementById("toastContainer") || createToastContainer();
    
    const toast = document.createElement("div");
    toast.className = `toast toast-${type}`;
    
    const icon = getToastIcon(type);
    toast.innerHTML = `
      <span class="toast-icon">${icon}</span>
      <span>${escapeHtml(message)}</span>
    `;
    
    toastContainer.appendChild(toast);
    
    // Trigger show animation
    setTimeout(() => toast.classList.add("toast-show"), 100);
    
    // Auto-remove toast
    setTimeout(() => {
      toast.classList.remove("toast-show");
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 300);
    }, duration);
    
    // Log errors for debugging
    if (type === "error") {
      console.error("Toast Error:", message);
    }
  } catch (error) {
    console.error("Failed to show toast:", error);
  }
}

function createToastContainer() {
  const container = document.createElement("div");
  container.id = "toastContainer";
  container.style.cssText = `
    position: fixed; top: 20px; right: 20px; z-index: 10000;
    display: flex; flex-direction: column; gap: 10px; max-width: 350px;
  `;
  document.body.appendChild(container);
  return container;
}

function getToastIcon(type) {
  const icons = {
    success: "✅",
    error: "❌",
    warning: "⚠️",
    info: "ℹ️"
  };
  return icons[type] || "ℹ️";
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Enhanced retry mechanism with exponential backoff
async function retryOperation(operation, maxRetries = MAX_RETRIES) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      if (!isOnline) {
        throw new Error("No internet connection");
      }
      
      const result = await Promise.race([
        operation(),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error("Request timeout")), REQUEST_TIMEOUT)
        )
      ]);
      
      return result;
    } catch (error) {
      console.warn(`Attempt ${attempt}/${maxRetries} failed:`, error.message);
      
      if (attempt === maxRetries) {
        networkErrorCount++;
        if (networkErrorCount >= 3) {
          showNetworkError();
        }
        throw new Error(`Operation failed after ${maxRetries} attempts: ${error.message}`);
      }
      
      // Exponential backoff
      const delay = RETRY_DELAY * Math.pow(2, attempt - 1);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Network error indicator
function showNetworkError() {
  let errorDiv = document.getElementById("networkError");
  if (!errorDiv) {
    errorDiv = document.createElement("div");
    errorDiv.id = "networkError";
    errorDiv.className = "network-error-indicator";
    errorDiv.innerHTML = `
      <i class="fa-solid fa-wifi"></i>
      <span>Network issues detected. Some features may not work properly.</span>
      <button class="retry-button" onclick="retryConnection()">Retry</button>
    `;
    document.body.insertBefore(errorDiv, document.body.firstChild);
  }
}

function hideNetworkError() {
  const errorDiv = document.getElementById("networkError");
  if (errorDiv) {
    errorDiv.remove();
  }
}

async function retryConnection() {
  try {
    const response = await fetch("http://localhost:5001/health", {
      method: "GET",
      timeout: 5000
    });
    
    if (response.ok) {
      networkErrorCount = 0;
      hideNetworkError();
      showToast("Connection restored", "success");
      return true;
    }
  } catch (error) {
    showToast("Still unable to connect", "error");
  }
  return false;
}

// Custom cancel confirmation functions
function showCancelRideConfirmation() {
  const confirmDiv = document.getElementById("cancelConfirmation");
  const cancelBtn = document.getElementById("cancelRideBtn");
  
  if (confirmDiv && cancelBtn) {
    confirmDiv.style.display = 'block';
    cancelBtn.style.opacity = '0.5';
    cancelBtn.disabled = true;
  }
}

function hideCancelRideConfirmation() {
  const confirmDiv = document.getElementById("cancelConfirmation");
  const cancelBtn = document.getElementById("cancelRideBtn");
  
  if (confirmDiv && cancelBtn) {
    confirmDiv.style.display = 'none';
    cancelBtn.style.opacity = '1';
    cancelBtn.disabled = false;
  }
}

function confirmCancelRide() {
  hideCancelRideConfirmation();
  cancelRide();
}

function confirmForceCancelRide() {
  hideCancelRideConfirmation();
  cancelRide(true); // Force cancel
}

// Tracking layout cancel confirmation functions
function showCancelRideConfirmationTracking() {
  const confirmDiv = document.getElementById("cancelConfirmationTracking");
  const cancelBtn = document.getElementById("cancelRideBtnTracking");
  
  if (confirmDiv && cancelBtn) {
    confirmDiv.style.display = 'block';
    cancelBtn.style.opacity = '0.5';
    cancelBtn.disabled = true;
  }
}

function hideCancelRideConfirmationTracking() {
  const confirmDiv = document.getElementById("cancelConfirmationTracking");
  const cancelBtn = document.getElementById("cancelRideBtnTracking");
  
  if (confirmDiv && cancelBtn) {
    confirmDiv.style.display = 'none';
    cancelBtn.style.opacity = '1';
    cancelBtn.disabled = false;
  }
}

function confirmCancelRideTracking() {
  hideCancelRideConfirmationTracking();
  cancelRide();
}

function confirmForceCancelRideTracking() {
  hideCancelRideConfirmationTracking();
  cancelRide(true); // Force cancel
}

// Emergency clear function - clears all ride data locally
function emergencyClearRideData() {
  console.log("Emergency clearing ride data");
  
  // Clear localStorage
  localStorage.removeItem('activeRide');
  
  // Reset all variables
  rideId = null;
  assignedCarId = null;
  rideStatus = 'none';
  currentRideData = null;
  isSubmittingRide = false;
  
  // Clear UI
  resetRideState();
  
  showToast("All ride data cleared! You can now make a new request.", "success");
}

// Enhanced loading state management
function showLoading(elementId, text = "Loading...") {
  const element = document.getElementById(elementId);
  if (element) {
    element.innerHTML = `<div class="loading-spinner"></div>${text}`;
    element.disabled = true;
  }
}

function hideLoading(elementId, originalText) {
  const element = document.getElementById(elementId);
  if (element) {
    element.innerHTML = originalText;
    element.disabled = false;
  }
}

// Enhanced socket connection with error handling
function connectSocket() {
  try {
    if (socket && socket.connected) {
      return; // Already connected
    }
    
    socket = io("http://localhost:5001", { 
      transports: ["websocket"],
      timeout: 10000,
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 2000
    });
    
    socket.on("connect", () => {
      console.log("Connected to Taxi server for ride updates!");
      showToast("Connected to server!", "success");
      hideNetworkError();
      
      // Join ride room if we have an active ride
      if (rideId) {
        console.log("Joining ride room:", rideId);
        socket.emit("join-ride-room", { rideId: rideId });
      }
      
      // Check for ongoing ride on page load
      checkForOngoingRide();
    });
    
    socket.on("disconnect", (reason) => {
      console.warn("Disconnected from server:", reason);
      if (reason === 'io server disconnect') {
        showToast("Server disconnected. Attempting to reconnect...", "warning");
      }
    });
    
    socket.on("connect_error", (error) => {
      console.error("Socket connection error:", error);
      showToast("Connection failed. Check your internet connection.", "error");
      showNetworkError();
    });
    
    socket.on("reconnect", (attemptNumber) => {
      console.log("Reconnected to server after", attemptNumber, "attempts");
      showToast("Reconnected to server!", "success");
      hideNetworkError();
    });
    
    socket.on("reconnect_error", (error) => {
      console.error("Reconnection failed:", error);
      showNetworkError();
    });
    
    // Enhanced ride event handlers with error handling
    socket.on("ride-accepted", function(data) {
      try {
        if (data.rideId === rideId) {
          rideStatus = 'accepted';
          assignedCarId = data.carId;
          currentRideData = data;
          
          // Join ride room for real-time updates
          console.log("Joining ride room for tracking:", rideId);
          socket.emit("join-ride-room", { rideId: rideId });
          
          const statusElement = document.getElementById("rideStatus");
          if (statusElement) {
            statusElement.textContent = "✅ Driver accepted your ride! Car is driving to you...";
            statusElement.style.color = "#2e7d32";
          }
          
          // Enhanced toast notification for ride acceptance
          const driverName = data.driverName || "Driver";
          const carName = data.carName || "your assigned car";
          showToast(`🚗 Great news! ${driverName} accepted your ride with ${carName}! They're on their way to pick you up.`, "success");
          
          // Play acceptance sound
          try {
            const audio = new Audio('data:audio/wav;base64,UklGRsgEAABXQVZFZm10IBAAAAABAAEAESsAABErAAABAAgAZGF0YQoEAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+PyvmASBjiJ0+7NdSoFJXnE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8=');
            audio.volume = 0.5;
            audio.play().catch(e => console.warn('Could not play acceptance sound:', e));
          } catch (e) {
            console.warn('Audio notification failed:', e);
          }
          
          // Save ride state to localStorage
          saveRideState();
          
          // Start periodic location updates
          startLocationUpdates();
          
          // Move to tracking layout
          showTrackingLayout(data);
        }
      } catch (error) {
        console.error("Error handling ride-accepted:", error);
        showToast("Error processing ride acceptance", "error");
      }
    });
    
    socket.on("ride-cancelled", function(data) {
      try {
        if (data.rideId === rideId) {
          rideStatus = 'cancelled';
          
          // Immediately hide the tracking layout
          const activeRideTrackingBox = document.getElementById("activeRideTrackingBox");
          if (activeRideTrackingBox) {
            activeRideTrackingBox.classList.add("hidden");
          }
          
          // Stop location updates immediately
          stopLocationUpdates();
          
          // Clear the assigned car marker immediately
          if (assignedCarMarker) {
            assignedCarMarker.setMap(null);
            assignedCarMarker = null;
          }
          
          const statusElement = document.getElementById("rideStatus");
          if (statusElement) {
            statusElement.textContent = "❌ Ride was cancelled.";
            statusElement.style.color = "crimson";
          }
          
          // Enhanced toast notification for ride cancellation
          const reason = data.reason || "unknown reason";
          if (data.cancelledBy === "driver") {
            showToast(`❌ Your driver cancelled the ride (${reason}). Please try requesting another ride.`, "error");
          } else if (data.cancelledBy === "rider") {
            showToast("❌ You have cancelled your ride request.", "info");
          } else {
            showToast(`❌ Ride was cancelled (${reason}). Please try again.`, "warning");
          }
          
          setTimeout(() => {
            clearRideState();
            resetRideState();
          }, 2000);
        }
      } catch (error) {
        console.error("Error handling ride-cancelled:", error);
      }
    });
    
    // Additional socket event handlers for car tracking, status updates, etc.
    socket.on("car-update", function(data) {
      try {
        console.log("Received car-update:", data);
        console.log("Current assignedCarId:", assignedCarId, "Current rideStatus:", rideStatus);
        
        if (data.carId === assignedCarId && (rideStatus === 'accepted' || rideStatus === 'driving_to_pickup' || rideStatus === 'arrived_at_pickup' || rideStatus === 'in_progress')) {
          console.log("Updating car location to:", data.lat, data.lng);
          updateAssignedCarLocation(data.lat, data.lng);
          updateRideETA(data);
        } else {
          console.log("Skipping car location update - condition not met");
        }
      } catch (error) {
        console.error("Error handling car location update:", error);
      }
    });
    
    // Keep legacy support for car-location-update
    socket.on("car-location-update", function(data) {
      try {
        console.log("Received car-location-update:", data);
        console.log("Current assignedCarId:", assignedCarId, "Current rideStatus:", rideStatus);
        
        if (data.carId === assignedCarId && (rideStatus === 'accepted' || rideStatus === 'driving_to_pickup' || rideStatus === 'arrived_at_pickup' || rideStatus === 'in_progress')) {
          console.log("Updating car location to:", data.lat, data.lng);
          updateAssignedCarLocation(data.lat, data.lng);
          updateRideETA(data);
        } else {
          console.log("Skipping car location update - condition not met");
        }
      } catch (error) {
        console.error("Error handling car location update:", error);
      }
    });
    
    // Handle ride status updates
    socket.on("ride-status-update", function(data) {
      try {
        if (data.rideId === rideId) {
          console.log("Ride status update:", data.status);
          const previousStatus = rideStatus;
          rideStatus = data.status;
          
          // Show progressive toast notifications for status changes
          if (data.status === 'driving_to_pickup' && previousStatus !== 'driving_to_pickup') {
            showToast("🚗 Your driver is now heading to pick you up!", "info");
          } else if (data.status === 'arrived_at_pickup' && previousStatus !== 'arrived_at_pickup') {
            showToast("🎯 Your driver has arrived at the pickup location!", "success");
          } else if (data.status === 'in_progress' && previousStatus !== 'in_progress') {
            showToast("🚗 Your ride has started! Enjoy your journey!", "info");
          }
          
          updateRideStatusDisplay(data);
          saveRideState();
        }
      } catch (error) {
        console.error("Error handling ride status update:", error);
      }
    });
    
    // Handle driver location updates specifically
    socket.on("driver-location-update", function(data) {
      try {
        console.log("Received driver-location-update:", data);
        if (data.rideId === rideId && assignedCarId) {
          console.log("Updating driver location for ride:", rideId);
          updateAssignedCarLocation(data.lat, data.lng);
          if (data.eta) {
            updateRideETA(data);
          }
        }
      } catch (error) {
        console.error("Error handling driver location update:", error);
      }
    });
    
    // Handle car tracking updates
    socket.on("car-tracking-update", function(data) {
      try {
        console.log("Received car-tracking-update:", data);
        if (data.carId === assignedCarId && rideId) {
          console.log("Car tracking update for carId:", data.carId);
          updateAssignedCarLocation(data.lat, data.lng);
          if (data.driverETA) {
            updateRideETA(data);
          }
        }
      } catch (error) {
        console.error("Error handling car tracking update:", error);
      }
    });
    
    // Handle driver arrival
    socket.on("driver-arrived", function(data) {
      try {
        if (data.rideId === rideId) {
          console.log("Driver arrived:", data);
          rideStatus = data.status;
          updateRideStatusDisplay(data);
          
          // Enhanced toast notification for driver arrival
          showToast("🎯 Your driver has arrived at the pickup location!", "success");
          
          // Play notification sound if available
          try {
            const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+PyvmASBjiJ0+7NdSoF');
            audio.volume = 0.3;
            audio.play().catch(e => console.warn('Could not play notification sound:', e));
          } catch (e) {
            console.warn('Audio notification failed:', e);
          }
          
          saveRideState();
        }
      } catch (error) {
        console.error("Error handling driver arrival:", error);
      }
    });
    
    // Handle ride start
    socket.on("ride-started", function(data) {
      try {
        if (data.rideId === rideId) {
          console.log("Ride started:", data);
          rideStatus = data.status;
          updateRideStatusDisplay(data);
          
          // Enhanced toast notification for ride start
          showToast("🚗 Your ride has started! Driving to your destination...", "info");
          
          // Additional UI feedback for ride start
          const activeRideBox = document.getElementById("activeRideBox");
          if (activeRideBox) {
            activeRideBox.style.borderColor = "#4caf50";
            activeRideBox.style.boxShadow = "0 4px 20px rgba(76, 175, 80, 0.3)";
          }
          
          saveRideState();
        }
      } catch (error) {
        console.error("Error handling ride start:", error);
      }
    });

    // Handle ride completion
    socket.on("ride-completed", function(data) {
      try {
        if (data.rideId === rideId) {
          console.log("Ride completed:", data);
          rideStatus = "completed";
          updateRideStatusDisplay(data);
          
          // Enhanced toast notification for ride completion
          if (data.reason === "Completed") {
            showToast("🎉 Ride completed successfully! Thank you for using CarmaGO!", "success");
          } else if (data.reason === "Battery dead") {
            showToast("⚠️ Ride ended due to low battery. We apologize for the inconvenience.", "warning");
          } else if (data.reason === "Cancelled") {
            showToast("❌ Ride was cancelled.", "warning");
          } else {
            showToast("✅ Your ride has ended. Thank you for using CarmaGO!", "info");
          }
          
          // Play completion sound
          try {
            const audio = new Audio('data:audio/wav;base64,UklGRuIJAABXQVZFZm10IBAAAAABAAEAESsAABErAAABAAgAZGF0YQoJAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+PyvmASBjiJ0+7NdSoFJXnE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8aBzuA0e7MdSgEI3nE8N2OPgkTXbLj7aVSEAxOpd3yrV8=');
            audio.volume = 0.6;
            audio.play().catch(e => console.warn('Could not play completion sound:', e));
          } catch (e) {
            console.warn('Audio notification failed:', e);
          }
          
          // Visual feedback for completion
          const activeRideBox = document.getElementById("activeRideBox");
          if (activeRideBox) {
            activeRideBox.style.borderColor = "#4caf50";
            activeRideBox.style.backgroundColor = "#e8f5e8";
            activeRideBox.style.animation = "pulse 0.5s ease-in-out";
          }
          
          // Clear ride state after a delay to show completion message
          setTimeout(() => {
            clearRideState();
          }, 3000);
        }
      } catch (error) {
        console.error("Error handling ride completion:", error);
      }
    });
    
    // Handle ride request timeout
    socket.on("ride-request-timeout", function(data) {
      try {
        if (data.rideId === rideId) {
          console.log("Ride request timed out:", data);
          rideStatus = 'none';
          
          // Enhanced timeout notification
          showToast("⏰ No drivers available at the moment. Please try again or adjust your pickup location.", "warning");
          
          // Clear the waiting state
          setTimeout(() => {
            clearRideState();
            resetRideState();
          }, 2000);
        }
      } catch (error) {
        console.error("Error handling ride timeout:", error);
      }
    });
    
    // Handle no drivers available
    socket.on("no-drivers-available", function(data) {
      try {
        if (data.rideId === rideId) {
          console.log("No drivers available:", data);
          rideStatus = 'none';
          
          // Enhanced no drivers notification
          showToast("🚫 No drivers are currently available in your area. Please try again later.", "warning");
          
          // Clear the waiting state
          setTimeout(() => {
            clearRideState();
            resetRideState();
          }, 2000);
        }
      } catch (error) {
        console.error("Error handling no drivers available:", error);
      }
    });
    
  } catch (error) {
    console.error("Failed to initialize socket connection:", error);
    showToast("Failed to connect to server", "error");
    showNetworkError();
  }
}

// ...existing code...
</script>

<!-- Load Google Maps API after all other scripts -->
<script>
  // Load Google Maps API dynamically
  function loadGoogleMapsAPI() {
    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=AIzaSyB-8K0ndNli1FxzigKdSe3T0bnqUCw3D_o&libraries=places,geometry&callback=initMap&loading=async`;
    script.async = true;
    script.defer = true;
    document.body.appendChild(script);
  }

  // Load the API once the page is ready
  document.addEventListener('DOMContentLoaded', () => {
    // Check authentication first (redundant check for extra security)
    if (!requireAuthentication("Please log in to request a ride")) {
      return; // Stop initialization if not authenticated
    }
    
    // Initialize button state
    updateRequestButtonState();
    loadGoogleMapsAPI();
  });

  // Mobile menu toggle
  function toggleMobileMenu() {
    const navLinks = document.getElementById("nav-links");
    const toggleBtn = document.querySelector(".mobile-menu-toggle");
    
    navLinks.classList.toggle("mobile-active");
    toggleBtn.classList.toggle("active");
  }

  function logout() {
    logoutUser(); // Use shared logout function
  }
</script>

</body>
</html>
